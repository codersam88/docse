\documentclass[a4paper,11pt]{article}
\usepackage{graphicx}
\usepackage{algorithmic}

\title{High Level Design Document \\ Bin-packing VM Consolidation Algorithm}
\author{Surineni Sampath Kumar 13MCMT49}


\date{}

\begin{document}
\maketitle
\pagebreak
\tableofcontents
\pagebreak

\section{Detailed Design}
\subsection{PM Modifier Module}
This module will be called by Parser module and User Interface module for
\begin{itemize}
 \item Adding a Virtual Machine(VM),
 \item Deleting a VM,
 \item Switching off a PM,
 \item Switching on a PM and
 \item Consolidation
\end{itemize}
\subsubsection{Interface Data Structures}
\begin{enumerate}
 \item PMstruct
 \end{enumerate}
\textbf{PMstruct}
\\

Different fields in PMstruct data structure are
\begin{enumerate}
 \item PM\textunderscore ID - final String
 \item res\textunderscore cap - integer
 \item VM\textunderscore list - array of type class VMstruct
 \item onSate - integer
\end{enumerate}

This is the data structure returned to status() function which is called by User Interface
\\
\subsubsection{Internal Data Structures}
\begin{enumerate}
 \item VMstruct
\end{enumerate}
\textbf{VMstruct}
\\

Different fields in VMstruct data structure are
\begin{enumerate}
 \item VM\textunderscore ID - final String
 \item cap - integer
\end{enumerate}
This is the structure used by PM modifier to create a VM.
\subsubsection{Interface Functions}
\textbf{ void deleteVM(VM\textunderscore ID)}
\\
\textbf{Description :} The purpose of this function is to delete the VM which is passed as an input parameter to while calling this function.
\\
\textbf{Input parameters :} The VM\textunderscore ID of VM which has to be deleted.
\\
\textbf{Output parameters :} NONE.
\\
\textbf{Return Values :} None, because all the error conditions that may arise are handled by data validation in user interface.
\\
\textbf{Pseudocode :}
\begin{algorithmic}[1]
\STATE void deleteVM(\emph{VM\textunderscore ID)}
\FOR {\textbf{each} \emph{PMstruct} \textbf{in} \emph{PMarray}}
\FOR {\textbf{each} \emph{VMstruct} \textbf{in} \emph{VMarray}}
\IF {\emph{VM\textunderscore ID} matches}
\STATE delete this VM
\ENDIF
\ENDFOR
\ENDFOR
\end{algorithmic}
\textbf{ void addVM(cap)}
\\
\textbf{Description :} This function checks the PM's if there is enough capacity available and if available adds the VM to it. If there is no enough capacity 
it returns an error.
\\
\textbf{Input parameters :} The cap of VM which is to be added. The ID for VM is automatically generated by the function.
\\
\textbf{Output parameters :} NONE.
\\
\textbf{Return Values :} If sufficient capacity to add a VM is not available it returns \textbf{No enough capacity} error message
\\
\textbf{Pseudocode :}
\begin{algorithmic}[1]
\STATE void addVM(\emph{cap)}
\FOR {\textbf{each} \emph{PMstruct} \textbf{in} \emph{PMarray}}
\IF {\emph{res\textunderscore cap} $\leq 1$ \emph{cap}}
\STATE create an ID for this VM
\STATE add VM to this PM
\ENDIF
\ENDFOR
\end{algorithmic}
\textbf{ void consolidate()}
\\
\textbf{Description :} The function runs the consolidation algorithm to consolidate VM's in PM's and swithces 
off the PM's if any of the PM's become empty after consolidation.
\\
\textbf{Input parameters :} NONE.
\\
\textbf{Output parameters :} NONE.
\\
\textbf{Return Values :} No possible error conditions
\\
\textbf{Pseudocode :}
\begin{algorithmic}[1]
\STATE void consolidate()
\STATE quicksort(\emph{PMarray,lo,hi}) \COMMENT{sorts PMs in decreasing order of their residual capacity}
\FOR {\emph{i} from \emph{0} to \emph{PMarray.lenght-1}}
\STATE quicksort(\emph{PMarray[i].VMarray, lo, hi}) \COMMENT{sorts VMs in decreasing order of their capacity}
\FOR {\textbf{each} \emph{VMstruct} \textbf{in} \emph{VMarray}}
\FOR {\emph{i} from \emph{PMarray.lenght-1} to \emph{0}}
\IF {\emph{PMarray[i].PMstruct.res\textunderscore cap} $ \geq $\emph{VMarray.VMstruct.cap}}
\STATE move VMstruct into this PMstruct's VMarray
\ENDIF
\ENDFOR
\ENDFOR
\ENDFOR
\STATE void quicksort(\emph{PMarray,lo,hi})
\IF {\emph{lo} $ < $ \emph{hi}}
\STATE p = pivot(\emph{PMarray,lo,hi})
\STATE left, right = partition(\emph{PMarray, p, lo, hi})
\STATE quicksort(\emph{PMarray, lo, left})
\STATE quicksort(\emph{PMarray, right, hi})
\ENDIF
\end{algorithmic}
\begin{algorithmic}[1]
\STATE int partition(\emph{PMarray, left, right, pivotIndex})
\STATE pivotValue = PMarray[pivotIndex]
\STATE swap PMarray[pivotIndex] and PMarray[right]
\STATE storeIndex = left
\FOR {\emph{i} from \emph{left} to \emph{right - 1}}
\IF {\emph{PMarray[i]} $\leq 1$ \emph{pivotValue}}
\STATE swap \emph{PMarray[i]} and \emph{PMarray[storeIndex]}
\STATE \emph{storeIndex} = \emph{storeIndex} + 1
\ENDIF
\STATE swap \emph{PMarray[storeIndex]} and \emph{PMarray[right]}
\ENDFOR
\RETURN \emph{storeIndex}
\end{algorithmic}
\textbf{ void switchOffPM(PM\textunderscore ID)}
\\
\textbf{Description :} This function switches off the specified PM.
\\
\textbf{Input parameters :} PM ID of the PM which has to be switched off.
\\
\textbf{Output parameters :} NONE.
\\
\textbf{Return Values :} Returns error if the VM's in the current PM can't be consolidated in to other PM's.
\\
\textbf{Pseudocode :}
\begin{algorithmic}[1]
\STATE void switchOffPM(\emph{PM\textunderscore ID})
\FOR {\textbf{each} \emph{PMstruct} \textbf{in} \emph{PMarray}}
\IF {\emph{PM\textunderscore ID} matches}
\STATE change onState to OFF
\ENDIF
\ENDFOR
\end{algorithmic}
\textbf{ void switchOnPM(PM\textunderscore ID)}
\\
\textbf{Description :} This function switches on the specified PM.
\\
\textbf{Input parameters :} PM ID of the PM which has to be switched on.
\\
\textbf{Output parameters :} NONE.
\\
\textbf{Return Values :} No possible error condition.
\\
\textbf{Pseudocode :}
\begin{algorithmic}[1]
\STATE void switchOnPM(\emph{PM\textunderscore ID})
\FOR {\textbf{each} \emph{PMstruct} \textbf{in} \emph{PMarray}}
\IF {\emph{PM\textunderscore ID} matches}
\STATE change onState to ON
\ENDIF
\ENDFOR
\end{algorithmic}
\end{document}